#!/usr/bin/env python

''' 
 * All rights Reserved, Designed By HIT-Bioinformatics   
 * @Title:  process.py
 * @Package: 
 * @Description: Control the deNSF pipeline
 * @author: tjiang
 * @date: June 11 2018
 * @version V1.0.1     
'''

import argparse
import sys
import logging
import pysam
import cigar

INS_flag = {1:'I'}
DEL_flag = {2:'D'}
clip_flag = {4:'S', 5:'H'}
CLIP_note = dict()

def acquire_clip_pos(deal_cigar):
	seq = list(cigar.Cigar(deal_cigar).items())
	if seq[0][1] == 'S':
		first_pos = seq[0][0]
	else:
		first_pos = 0
	if seq[-1][1] == 'S':
		last_pos = seq[-1][0]
	else:
		last_pos = 0
	bias = 0
	for i in seq:
		if i[1] == 'M' or i[1] == 'D':
			bias += i[0]

	return [first_pos, last_pos, bias]

def organize_split_signal(chr, primary_info, Supplementary_info, total_L, low_bandary):
	overlap = list()
	for i in Supplementary_info:
		seq = i.split(',')
		local_chr = seq[0]
		local_start = int(seq[1])
		local_cigar = seq[3]

		dic_starnd = {1:'+', 2: '-'}

		if dic_starnd[primary_info[4]] != seq[2]:
			continue
		if chr != local_chr:
			# return overlap
			continue
		local_set = acquire_clip_pos(local_cigar)
		# if len(local_set) == 0:
		# 	continue
		if primary_info[0] < local_start:
			if primary_info[3]+local_set[0]-total_L > low_bandary:
				overlap.append([total_L - primary_info[3], local_set[0], primary_info[1]])
		else:
			if local_set[1]+primary_info[2]-total_L > low_bandary:
				overlap.append([total_L - local_set[1], primary_info[2], local_start+local_set[2]-1])
			# exist some bugs

		# if local_start <= primary_end + 50 and local_start >= primary_end - 50:
		# 	local_set = acquire_clip_pos(local_cigar)
		# 	if len(local_set) != 0:
		# 		overlap.append([primary_clip, sum(local_set) - primary_clip])
	return overlap

def detect_flag(Flag):
	# Signal
	Normal_foward = 1 >> 1
	Abnormal = 1 << 2
	Reverse_complement = 1 << 4
	Supplementary_map = 1 << 11

	signal = {Abnormal: 0, Normal_foward: 1, Reverse_complement: 2, Supplementary_map:3, Reverse_complement | Supplementary_map:4}
	if Flag in signal:
		return signal[Flag]
	else:
		return 0

def store_clip_pos(locus, chr, flag):
	# about collecting breakpoint from clipping 
	hash_1 = int(locus /10000)
	mod = locus % 10000
	hash_2 = int(mod / 50)
	element = [locus, flag]

	if hash_1 not in CLIP_note[chr]:
		CLIP_note[chr][hash_1] = dict()
		CLIP_note[chr][hash_1][hash_2] = list()
		CLIP_note[chr][hash_1][hash_2].append(element)
	else:
		if hash_2 not in CLIP_note[chr][hash_1]:
			CLIP_note[chr][hash_1][hash_2] = list()
			CLIP_note[chr][hash_1][hash_2].append(element)
		else:
			CLIP_note[chr][hash_1][hash_2].append(element)

def parse_read(read, Chr_name, low_bandary):
	'''
	Check:	1.Flag
			2.Supplementary mapping
			3.Seq
	'''

	INS_ME_pos = list()

	# Nonmapped_reads

	process_signal = detect_flag(read.flag)
	if process_signal == 0:
		return INS_ME_pos

	pos_start = read.reference_start
	shift = 0
	_shift_read_ = 0
	pos_end = read.reference_end
	primary_clip_0 = 0
	primary_clip_1 = 0
	for element in read.cigar:
		if element[0] == 0 or element[0] == 2:
			shift += element[1]
		if element[0] != 2:
			_shift_read_ += element[1]
		if element[0] in INS_flag and element[1] > low_bandary:
			shift += 1
			# MEI_contig = read.query_sequence[_shift_read_ - element[1]:_shift_read_]

			# INS_ME_pos.append([pos_start + shift, element[1], MEI_contig])
			INS_ME_pos.append([Chr_name, pos_start + shift, element[1]])

			# print read.query_name, "I", pos_start + shift
			# print MEI_contig

		if element[0] in clip_flag:

			if shift == 0:
				primary_clip_0 = element[1]
			else:
				primary_clip_1 = element[1]

			if element[1] > low_bandary:
				if shift == 0:
					clip_pos = pos_start - 1
					# clip_contig = read.query_sequence[:element[1]]
					store_clip_pos(clip_pos, Chr_name, 0)

					# primary_clip_0 = element[1]
					# left clip size

				else:
					clip_pos = pos_start + shift - 1
					# primary_clip = read.query_length - element[1]
					# clip_contig = read.query_sequence[read.query_length - element[1]:]
					store_clip_pos(clip_pos, Chr_name, 1)

					# primary_clip_1 = read.query_length - element[1]
					# right clip size

	if process_signal == 1 or process_signal == 2:
		Tags = read.get_tags()
		chr = Chr_name
		# primary_clip = pos_start
		primary_info = [pos_start, pos_end, primary_clip_0, primary_clip_1, process_signal]

		for i in Tags:
			if i[0] == 'SA':
				Supplementary_info = i[1].split(';')[:-1]
				# print process_signal
				# print chr, primary_info, read.query_length
				# print read.cigar
				# print i[1].split(';')[-1]
				overlap = organize_split_signal(chr, primary_info, Supplementary_info, read.query_length, low_bandary)
				for k in overlap:
					# print k
					# MEI_contig = read.query_sequence[k[0]:k[1]]
					INS_ME_pos.append([Chr_name, k[2], k[1] - k[0]])

	return INS_ME_pos

def load_sam(sam_path, ):
	'''
	Load_BAM_File
	library:	pysam.AlignmentFile

	load_Ref_Genome
	library:	Bio
	'''
	# p1 = args.AlignmentFile
	# p2 = args.Output_prefix
	# p3 = args.Reference
	# Ref = load_ref(p3)

	samfile = pysam.AlignmentFile(sam_path)
	# print(samfile.get_index_statistics())
	contig_num = len(samfile.get_index_statistics())
	# print contig_num
	logging.info("The total number of chromsomes: %d"%(contig_num))
	# Acquire_Chr_name
	for _num_ in xrange(contig_num):
		Chr_name = samfile.get_reference_name(_num_)
		logging.info("Resolving the chromsome %s."%(Chr_name))
		# Chr_length = samfile.lengths[_num_]
		if Chr_name not in CLIP_note:
			# CLIP_note[Chr_name] = [0] * Chr_length
			# CLIP_note[Chr_name] = Q.PriorityQueue()
			CLIP_note[Chr_name] = dict()

		cluster_pos_INS = list()
		# cluster_pos_DEL = list()
		for read in samfile.fetch(Chr_name):
			feed_back = parse_read(read, Chr_name, 50)

			if len(feed_back) > 0:
				print read.query_name
				for i in feed_back:
					print i
					cluster_pos_INS.append(i)
				break
	# 		# if len(feed_back_del) > 0:
	# 		# 	for i in feed_back_del:
	# 		# 		cluster_pos_DEL.append(i)
	# 	# while not CLIP_note[Chr_name].empty():
	# 	# 	print Chr_name, CLIP_note[Chr_name].get()
	# 	# print CLIP_note[Chr_name][6]
	# 	cluster_pos_INS = sorted(cluster_pos_INS, key = lambda x:x[0])
	# 	# cluster_pos_DEL = sorted(cluster_pos_DEL, key = lambda x:x[0])
	# 	if len(cluster_pos_INS) == 0:
	# 		Cluster_INS = list()
	# 	else:
	# 		Cluster_INS = cluster(cluster_pos_INS, Chr_name, evidence_read, SV_size)

	# 	# if len(cluster_pos_DEL) == 0:
	# 	# 	Cluster_DEL = list()
	# 	# else:
	# 	# 	Cluster_DEL = cluster_del(cluster_pos_DEL, Chr_name, Ref)

	# 	logging.info("%d INS signal loci in the chromsome %s."%(len(Cluster_INS), Chr_name))

	# 	# print Cluster_DEL
	# 	# merge_siganl(Chr_name, Cluster)
	# 	# break

	# 	# merge step
	# 	# Final_result = combine_result(add_genotype(Cluster_INS, samfile), add_genotype(Cluster_DEL,samfile))

	# 	# print Final_result

	# 	# out_signal = open(p2, 'a+')
	# 	# for i in Final_result:
	# 	# 	for j in i:
	# 	# 		out_signal.write(j)
	# 	# out_signal.close()

	# 	# path = p2+Chr_name+'.fa'
	# 	# SeqIO.write(Final_result, path, "fasta")

	# # out_signal = open(p2, 'w')
	# # for i in total_signal:
	# # 	out_signal.write(i)
	# # out_signal.close()
	samfile.close()

if __name__ == '__main__':
	load_sam(sys.argv[1])
