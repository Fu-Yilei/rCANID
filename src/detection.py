#!/usr/bin/env python

''' 
 * All rights Reserved, Designed By HIT-Bioinformatics   
 * @Title:  detection.py
 * @Package: 
 * @Description: detect nsi
 * @author: tjiang
 * @date: Aug 17 2018
 * @version V1.0.1     
'''

import sys
import argparse
import logging
from CommandRunner import *
from produce_preNSI import *
from detect_final_NSI import *

USAGE="""\
	Detection of novel sequence insertion based on merged contigs mapping.
	First, align the contigs to reference genome with NGMLR.
	Next, extract inserted fragments and realign them.
	Thirdly, identify NSI fragments from realignment and filter false positive sequences.

	NGMLR & Samtools need to be imported in env path.
"""

def parseArgs(argv):
	parser = argparse.ArgumentParser(prog="process.py Detect", description=USAGE, formatter_class=argparse.RawDescriptionHelpFormatter)
	# parser.add_argument("AlignmentFile", type=str, help="the bam format file generated by ngmlr, within a '.bai' index file")
	parser.add_argument("input", metavar="[FASTA/FA]", type=str, help="Input contigs to be mapped")
	parser.add_argument("Reference", metavar="REFERENCE", type=str, help="the reference genome(fasta format)")
	parser.add_argument('temp_dir', type=str, help = "temporary directory to use for distributed jobs")
	# parser.add_argument("--temp", type=str, default=tempfile.gettempdir(), help="Where to save temporary files")
	parser.add_argument('output', type=str, help = "the prefix of novel sequence insertion pridections")
	parser.add_argument('signals', type=str, help = "storing cluster info file")

	# parser.add_argument('-s', '--min_support', help = "Mininum number of reads that support a ME.[%(default)s]", default = 5, type = int)
	# parser.add_argument('-l', '--min_length', help = "Mininum length of ME to be reported.[%(default)s]", default = 50, type = int)
	# parser.add_argument('-d', '--min_distance', help = "Mininum distance of two ME clusters.[%(default)s]", default = 20, type = int)
	# # parser.add_argument('-hom', '--homozygous', help = "The mininum score of a genotyping reported as a homozygous.[%(default)s]", default = 0.8, type = float)
	# # parser.add_argument('-het','--heterozygous', help = "The mininum score of a genotyping reported as a heterozygous.[%(default)s]", default = 0.3, type = float)
	# # parser.add_argument('-q', '--min_mapq', help = "Mininum mapping quality.[20]", default = 20, type = int)
	parser.add_argument('-t', '--threads', help = "Number of threads to use.[%(default)s]", default = 1, type = int)
	# parser.add_argument('-x', '--presets', help = "The sequencing type <pacbio,ont> of the reads.[%(default)s]", default = "pacbio", type = str)
	# # parser.add_argument("--temp", type=str, default=tempfile.gettempdir(), help="Where to save temporary files")
	# # parser.add_argument("--chunks", type=int, default=0, help="Create N scripts containing commands to each input of the fofn (%(default)s)")
	# # parser.add_argument("--debug", action="store_true")
	args = parser.parse_args(argv)

	# setupLogging(args.debug)
	# checkBlasrParams(args.params)
	
	# if args.output is None:
	# 	ext =  args.input[args.input.rindex('.'):]
	# 	main = args.input[:args.input.rindex('.')]
	# 	if ext in [".sam", ".bam"]:
	# 		args.output = main + ".tails" + ext
	# 	else:
	# 		args.output = main + ".tails.sam"
	return args

def call_ngmlr(inFile, ref, presets, nproc, outFile):

	# outFile = outFile + "map.sam"
	if outFile[-1] == '/':
		pre_fa = outFile + "pre.fa"
		outFile = outFile + inFile.split('/')[-1]+".sam"
	else:
		pre_fa = outFile + "/pre.fa"
		outFile = outFile + '/' + inFile.split('/')[-1]+".sam"

	logging.info("Running NGMLR...")
	cmd = ("ngmlr -r %s -q %s -o %s -t %d -x %s" % (ref, inFile, outFile, nproc, presets))
	r, o, e = exe(cmd)
	
	if r != 0:
		logging.error("NGMLR mapping failed!")
		logging.error("RETCODE %d" % (r))
		logging.error("STDOUT %s" % (str(o)))
		logging.error("STDERR %s" % (str(e)))
		logging.error("Exiting")
		exit(r)
	
	logging.info("Finished NGMLR mapping.")
	return outFile, pre_fa

def call_samtools(file, tempdir):
	logging.info("Running Samtools...")
	# samtools view -Sb ${WORK_PATH}_0001.sam | samtools sort -O bam -T /data/tjiang/ - > ${WORK_PATH}_0001.bam
	# samtools index ${WORK_PATH}_0001.bam
	bam_path = file[:-3] + "bam"
	cmd = ("samtools view -Sb %s | samtools sort -@ 4 -O bam -T %s - > %s && samtools index %s" % (file, tempdir, bam_path, bam_path))
	r, o, e = exe(cmd)
	if r != 0:
		logging.error("Samtools sort failed!")
		logging.error("RETCODE %d" % (r))
		logging.error("STDOUT %s" % (str(o)))
		logging.error("STDERR %s" % (str(e)))
		logging.error("Exiting")
		exit(r)
	logging.info("Finished SAM to sorted BAM.")
	return bam_path

def run(argv):
	import time
	args = parseArgs(argv)
	setupLogging(False)
	# print args
	starttime = time.time()

	samfile, pre_fa = call_ngmlr(args.input, args.Reference, "pacbio", args.threads, args.temp_dir)
	sorted_bamfile = call_samtools(samfile, args.temp_dir)

	# pre_fa = args.temp_dir
	load_final_alignment(sorted_bamfile, pre_fa)

	resamfile, temp = call_ngmlr(pre_fa, args.Reference, "pacbio", args.threads, args.temp_dir)

	if args.output[-1] == '/':
		OUTPUT = args.output + "final.bed"
	else:
		OUTPUT = args.output + "/final.bed"
	final_call(resamfile, OUTPUT, args.signals)

	logging.info("Finished in %0.2f seconds."%(time.time() - starttime))



if __name__ == '__main__':
	run(sys.argv[1:])
